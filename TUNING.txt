Tuning possibilities
====================

UPDATE
======
For updating the keys of entries (aka moving objects index), consider using update(). This function
is about twice as fast for small displacements and at least as fast as a put()/remove() combo.


MEMORY
======
There is little point in using 32bit instead of 64bit values, because prefix sharing takes care of
unused leading bits.
For floating point values, using a 32bit float instead of 64bit float should reduce memory usage
somewhat. However it is usually better to convert floating point values to integer values by a
constant. For example multiply by 10E6 to preserve 6 digit floating point precision.
Also, chose the multiplier such that it is not higher than the precision requires.
For example, if you have a precision of 6 digits after the decimal point, then multiply all values
by 1,000,000 before casting the to (long) and adding them to the tree.


SPEED
=====
The following suggestions concern mostly range queries.


Choose a type of query
----------------------
- queryExtent(): Fastest option when traversing (almost) all of the tree
- query():       Fastest option for for average result size > 50 (depending on data)
- queryAll():    Fastest option for for average result size < 50 (depending on data)


Iterators
---------
All iterators return by default the value of a stored key/value pair. All iterators also provide
three specialised methods nextKey(), nextValue() and nextEntry() to return only the key, only the 
value (just as next()) or the combined entry object. Iterating over the entry object has the 
disadvantage that the entries need to be created and create load on the GC. However, the entries
provide easy access to the key, especially for SOLID keys.


Data preprocessing
------------------
To improve speed, similar measures can be applied as suggested for MEMORY. For example it makes 
sense to transform values into integers by multiplication with a constant.

If data is stored as floats in IEEE representation (BiitTools.toSortableLong()), consider adding
or multiplying a constant such that the whole value domain falls into a single exponent. I.e.
shift the values such that all values have the same exponent. It can also help to shift values
such that all values have a positive sign.

For heterogenous data (combination of floats, integers, boolean, ...) consider shifting the
values such that the min/max values in each dimension have a similar distance in the integer 
representation. For example a 3D tree: [0...10][10..30][0..1000] multiply the first dimension by
100 and the second by 50, so that all dimensions have a range of about 1000.

The above is true if all dimension are queried with similar selectivity. If range queries in the
above example would mainly constrain the 2nd and 3rd dimension, then the first dimension should
NOT be multiplied. In other words, the more selective queries are on a given dimension, the more
wide should the dimension spread over the tree, i.e. the dimension should be given a higher 
multiplier.

  


